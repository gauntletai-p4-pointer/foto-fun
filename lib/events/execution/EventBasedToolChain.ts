import type { CanvasManager, CanvasObject } from '@/lib/editor/canvas/types'
import type { ActiveSelection } from '@/lib/migration/fabric-to-konva-types'
import { ExecutionContext } from './ExecutionContext'
import { EventStore } from '../core/EventStore'
import { KonvaObjectsBatchModifiedEvent } from '../canvas/CanvasEvents'
import { SelectionSnapshot } from '@/lib/ai/execution/SelectionSnapshot'
import { ServiceContainer } from '@/lib/core/ServiceContainer'
import type { TypedEventBus } from '@/lib/events/core/TypedEventBus'

export interface ToolChainOptions {
  canvasId: string
  canvas: CanvasManager
  eventStore: EventStore
  workflowId?: string
  metadata?: Record<string, unknown>
}

export interface ToolExecutionResult {
  success: boolean
  data?: any
  error?: string
  events?: Array<{ type: string; data: any }>
}

export class EventBasedToolChain {
  private context: ExecutionContext
  private canvas: CanvasManager
  private typedEventBus: TypedEventBus
  private selectionSnapshot: SelectionSnapshot | null = null
  private originalSelection: CanvasObject[] = []
  
  constructor(private options: ToolChainOptions) {
    this.context = new ExecutionContext(
      options.eventStore,
      options.canvasId,
      options.workflowId,
      options.metadata
    )
    this.canvas = options.canvas
    this.typedEventBus = ServiceContainer.getInstance().get<TypedEventBus>('TypedEventBus')
  }
  
  /**
   * Execute a tool in the chain
   */
  async execute(
    toolId: string,
    params: Record<string, unknown>,
    toolExecutor: (params: Record<string, unknown>) => Promise<ToolExecutionResult>
  ): Promise<ToolExecutionResult> {
    try {
      // Start the tool execution context
      this.context.startTool(toolId, params)
      
      // Execute the tool
      const result = await toolExecutor(params)
      
      // Complete the tool execution
      this.context.completeTool(toolId, result.success, result.data)
      
      // Emit any events generated by the tool
      if (result.events) {
        for (const event of result.events) {
          this.typedEventBus.emit(event.type as any, event.data)
        }
      }
      
      return result
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      this.context.failTool(toolId, errorMessage)
      
      return {
        success: false,
        error: errorMessage
      }
    }
  }
  
  /**
   * Execute multiple tools in sequence
   */
  async executeSequence(
    tools: Array<{
      toolId: string
      params: Record<string, unknown>
      executor: (params: Record<string, unknown>) => Promise<ToolExecutionResult>
    }>
  ): Promise<ToolExecutionResult[]> {
    const results: ToolExecutionResult[] = []
    
    for (const tool of tools) {
      const result = await this.execute(tool.toolId, tool.params, tool.executor)
      results.push(result)
      
      // Stop execution if a tool fails
      if (!result.success) {
        break
      }
    }
    
    return results
  }
  
  /**
   * Prepare canvas for AI operations
   */
  async prepareForAIOperation(requiresSelection: boolean = false): Promise<void> {
    // Store current selection state
    const selection = this.canvas.state.selection
    if (selection && selection.type === 'objects') {
      this.originalSelection = []
      for (const id of selection.objectIds) {
        const obj = this.findObject(id)
        if (obj) {
          this.originalSelection.push(obj)
        }
      }
    }
    
    // Create selection snapshot if needed
    if (requiresSelection && this.originalSelection.length > 0) {
      const { SelectionSnapshotFactory } = await import('@/lib/ai/execution/SelectionSnapshot')
      this.selectionSnapshot = SelectionSnapshotFactory.fromCanvas(this.canvas as any)
    }
    
    // Emit preparation event - workflow events are not in the registry yet
    // So we'll track this differently for now
    console.log('[EventBasedToolChain] Preparing for AI operation', {
      canvasId: this.options.canvasId,
      hasSelection: this.originalSelection.length > 0,
      selectionCount: this.originalSelection.length
    })
  }
  
  /**
   * Complete AI operation and restore state
   */
  async completeAIOperation(modifiedObjects?: CanvasObject[]): Promise<void> {
    // Handle modified objects
    if (modifiedObjects && modifiedObjects.length > 0) {
      const modifications = modifiedObjects.map(obj => {
        const original = this.originalSelection.find(o => o.id === obj.id)
        const foundObj = this.findObject(obj.id)
        return {
          object: foundObj || obj,
          previousState: original ? this.captureObjectState(original) : {},
          newState: this.captureObjectState(obj)
        }
      })
      
      // Emit batch modification event
      if (modifications.length > 0) {
        this.typedEventBus.emit('canvas.objects.batch.modified', {
          canvasId: this.options.canvasId,
          modifications
        })
      }
    }
    
    // Restore selection if needed
    if (this.selectionSnapshot) {
      await this.restoreSelection()
    }
    
    // Clear temporary state
    this.selectionSnapshot = null
    this.originalSelection = []
    
    // Log completion instead of emitting non-existent event
    console.log('[EventBasedToolChain] AI operation completed', {
      canvasId: this.options.canvasId,
      modifiedCount: modifiedObjects?.length || 0
    })
  }
  
  /**
   * Restore selection from snapshot
   */
  private async restoreSelection(): Promise<void> {
    if (!this.selectionSnapshot) return
    
    // Get the object IDs from the snapshot
    const objectIds = Array.from(this.selectionSnapshot.objectIds)
    if (objectIds.length > 0) {
      // Restore object selection
      this.canvas.setSelection({
        type: 'objects',
        objectIds
      })
    }
  }
  
  /**
   * Capture object state for event tracking
   */
  private captureObjectState(obj: CanvasObject): Record<string, unknown> {
    return {
      transform: { ...obj.transform },
      opacity: obj.opacity,
      visible: obj.visible,
      locked: obj.locked,
      blendMode: obj.blendMode,
      filters: obj.filters ? [...obj.filters] : [],
      style: obj.style ? { ...obj.style } : {},
      data: obj.data
    }
  }
  
  /**
   * Find object by ID
   */
  private findObject(id: string): CanvasObject | null {
    for (const layer of this.canvas.state.layers) {
      const obj = layer.objects.find(o => o.id === id)
      if (obj) return obj
    }
    return null
  }
  
  /**
   * Get the execution context
   */
  getContext(): ExecutionContext {
    return this.context
  }
  
  /**
   * Complete the workflow
   */
  complete(): void {
    this.context.completeWorkflow()
  }
  
  /**
   * Fail the workflow
   */
  fail(error: string): void {
    this.context.failWorkflow(error)
  }
  
  // Legacy compatibility methods for migration
  
  /**
   * @deprecated Use prepareForAIOperation instead
   */
  async prepareCanvas(requiresSelection: boolean = false): Promise<void> {
    console.warn('prepareCanvas is deprecated. Use prepareForAIOperation instead.')
    return this.prepareForAIOperation(requiresSelection)
  }
  
  /**
   * @deprecated Use completeAIOperation instead
   */
  async restoreCanvas(modifiedObjects?: CanvasObject[]): Promise<void> {
    console.warn('restoreCanvas is deprecated. Use completeAIOperation instead.')
    return this.completeAIOperation(modifiedObjects)
  }
  
  /**
   * Handle object selection for AI operations
   * This creates a temporary ActiveSelection-like structure for compatibility
   */
  async selectObjectsForAI(objectIds: string[]): Promise<void> {
    const objects: CanvasObject[] = []
    
    for (const id of objectIds) {
      const obj = this.findObject(id)
      if (obj) {
        objects.push(obj)
      }
    }
    
    if (objects.length === 0) return
    
    // For single object, just select it
    if (objects.length === 1) {
      this.canvas.setSelection({
        type: 'objects',
        objectIds: [objects[0].id]
      })
      return
    }
    
    // For multiple objects, create a group selection
    // In Konva, we handle this through the selection system
    this.canvas.setSelection({
      type: 'objects',
      objectIds: objects.map(o => o.id)
    })
    
    // Emit selection event for tracking
    this.typedEventBus.emit('selection.changed', {
      selection: this.canvas.state.selection,
      previousSelection: null
    })
  }
  
  /**
   * Clear object selection
   */
  async clearObjectSelection(): Promise<void> {
    const previousSelection = this.canvas.state.selection
    this.canvas.deselectAll()
    
    if (previousSelection) {
      this.typedEventBus.emit('selection.cleared', {
        previousSelection
      })
    }
  }
} 