import type { CanvasObject } from '@/lib/editor/objects/types'
import { CanvasManager } from '@/lib/editor/canvas/CanvasManager'
import { ExecutionContext } from './ExecutionContext'
import { EventStore } from '../core/EventStore'
import { SelectionSnapshot } from '@/lib/ai/execution/SelectionSnapshot'
import { ServiceContainer } from '@/lib/core/ServiceContainer'
import type { TypedEventBus } from '@/lib/events/core/TypedEventBus'

export interface ToolChainOptions {
  canvasId: string
  canvas: CanvasManager
  eventStore: EventStore
  workflowId?: string
  metadata?: Record<string, unknown>
}

export interface ToolExecutionResult {
  success: boolean
  data?: unknown
  error?: string
  events?: Array<{ type: string; data: unknown }>
}

export class EventBasedToolChain {
  private context: ExecutionContext
  private canvas: CanvasManager
  private typedEventBus: TypedEventBus
  private selectionSnapshot: SelectionSnapshot | null = null
  private originalSelection: CanvasObject[] = []
  
  constructor(private options: ToolChainOptions) {
    this.context = new ExecutionContext(
      options.eventStore,
      options.canvasId,
      options.workflowId,
      options.metadata
    )
    this.canvas = options.canvas
    this.typedEventBus = ServiceContainer.getInstance().getSync<TypedEventBus>('TypedEventBus')
  }
  
  /**
   * Execute a tool in the chain
   */
  async execute(
    toolId: string,
    params: Record<string, unknown>,
    toolExecutor: (params: Record<string, unknown>) => Promise<ToolExecutionResult>
  ): Promise<ToolExecutionResult> {
    try {
      // Start the tool execution context
      this.context.startTool(toolId, params)
      
      // Execute the tool
      const result = await toolExecutor(params)
      
      // Complete the tool execution
      this.context.completeTool(toolId, result.success, result.data)
      
      // Emit any events generated by the tool
      if (result.events) {
        for (const event of result.events) {
          // Check if the event type exists in the registry
          if (event.type in this.typedEventBus) {
            // Type assertion needed since event types are dynamic
            this.typedEventBus.emit(event.type as keyof import('@/lib/events/core/TypedEventBus').EventRegistry, event.data as never)
          } else {
            console.warn(`[EventBasedToolChain] Unknown event type: ${event.type}`)
          }
        }
      }
      
      return result
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      this.context.failTool(toolId, errorMessage)
      
      return {
        success: false,
        error: errorMessage
      }
    }
  }
  
  /**
   * Execute multiple tools in sequence
   */
  async executeSequence(
    tools: Array<{
      toolId: string
      params: Record<string, unknown>
      executor: (params: Record<string, unknown>) => Promise<ToolExecutionResult>
    }>
  ): Promise<ToolExecutionResult[]> {
    const results: ToolExecutionResult[] = []
    
    for (const tool of tools) {
      const result = await this.execute(tool.toolId, tool.params, tool.executor)
      results.push(result)
      
      // Stop execution if a tool fails
      if (!result.success) {
        break
      }
    }
    
    return results
  }
  
  /**
   * Prepare canvas for AI operations
   */
  async prepareForAIOperation(requiresSelection: boolean = false): Promise<void> {
    // Store current selection state
    const selectedIds = Array.from(this.canvas.state.selectedObjectIds)
    if (selectedIds.length > 0) {
      this.originalSelection = []
      for (const id of selectedIds) {
        const obj = this.findObject(id)
        if (obj) {
          this.originalSelection.push(obj)
        }
      }
    }
    
    // Create selection snapshot if needed
    if (requiresSelection && this.originalSelection.length > 0) {
      const { SelectionSnapshotFactory } = await import('@/lib/ai/execution/SelectionSnapshot')
      this.selectionSnapshot = SelectionSnapshotFactory.fromCanvas(this.canvas)
    }
    
    // Emit preparation event - workflow events are not in the registry yet
    // So we'll track this differently for now
    console.log('[EventBasedToolChain] Preparing for AI operation', {
      canvasId: this.options.canvasId,
      hasSelection: this.originalSelection.length > 0,
      selectionCount: this.originalSelection.length
    })
  }
  
  /**
   * Complete AI operation and restore state
   */
  async completeAIOperation(modifiedObjects?: CanvasObject[]): Promise<void> {
    // Handle modified objects
    if (modifiedObjects && modifiedObjects.length > 0) {
      const modifications = modifiedObjects.map(obj => {
        const original = this.originalSelection.find(o => o.id === obj.id)
        const foundObj = this.findObject(obj.id)
        return {
          object: foundObj || obj,
          previousState: original ? this.captureObjectState(original) : {},
          newState: this.captureObjectState(obj)
        }
      })
      
      // Emit batch modification event
      if (modifications.length > 0) {
        this.typedEventBus.emit('canvas.objects.batch.modified', {
          canvasId: this.options.canvasId,
          modifications
        })
      }
    }
    
    // Restore selection if needed
    if (this.selectionSnapshot) {
      await this.restoreSelection()
    }
    
    // Clear temporary state
    this.selectionSnapshot = null
    this.originalSelection = []
    
    // Log completion instead of emitting non-existent event
    console.log('[EventBasedToolChain] AI operation completed', {
      canvasId: this.options.canvasId,
      modifiedCount: modifiedObjects?.length || 0
    })
  }
  
  /**
   * Restore selection from snapshot
   */
  private async restoreSelection(): Promise<void> {
    if (!this.selectionSnapshot) return
    
    // Get the object IDs from the snapshot
    const objectIds = Array.from(this.selectionSnapshot.objectIds)
    if (objectIds.length > 0) {
      // Restore object selection
      this.canvas.setSelection({
        type: 'objects',
        objectIds
      })
    }
  }
  
  /**
   * Capture object state for event tracking
   */
  private captureObjectState(obj: CanvasObject): Record<string, unknown> {
    return {
      x: obj.x,
      y: obj.y,
      width: obj.width,
      height: obj.height,
      rotation: obj.rotation,
      scaleX: obj.scaleX,
      scaleY: obj.scaleY,
      opacity: obj.opacity,
      visible: obj.visible,
      locked: obj.locked,
      blendMode: obj.blendMode,
      filters: obj.filters ? [...obj.filters] : [],
      data: obj.data
    }
  }
  
  /**
   * Find object by ID
   */
  private findObject(id: string): CanvasObject | null {
    return this.canvas.getObject(id)
  }
  
  /**
   * Get the execution context
   */
  getContext(): ExecutionContext {
    return this.context
  }
  
  /**
   * Complete the workflow
   */
  complete(): void {
    this.context.completeWorkflow()
  }
  
  /**
   * Fail the workflow
   */
  fail(error: string): void {
    this.context.failWorkflow(error)
  }
  
  // Legacy compatibility methods for migration
  
  /**
   * @deprecated Use prepareForAIOperation instead
   */
  async prepareCanvas(requiresSelection: boolean = false): Promise<void> {
    console.warn('prepareCanvas is deprecated. Use prepareForAIOperation instead.')
    return this.prepareForAIOperation(requiresSelection)
  }
  
  /**
   * @deprecated Use completeAIOperation instead
   */
  async restoreCanvas(modifiedObjects?: CanvasObject[]): Promise<void> {
    console.warn('restoreCanvas is deprecated. Use completeAIOperation instead.')
    return this.completeAIOperation(modifiedObjects)
  }
  
  /**
   * Handle object selection for AI operations
   * This creates a temporary ActiveSelection-like structure for compatibility
   */
  async selectObjectsForAI(objectIds: string[]): Promise<void> {
    const objects: CanvasObject[] = []
    
    for (const id of objectIds) {
      const obj = this.findObject(id)
      if (obj) {
        objects.push(obj)
      }
    }
    
    if (objects.length === 0) return
    
    // For single object, just select it
    if (objects.length === 1) {
      this.canvas.setSelection({
        type: 'objects',
        objectIds: [objects[0].id]
      })
      return
    }
    
    // For multiple objects, create a group selection
    // In Konva, we handle this through the selection system
    this.canvas.selectMultiple(objects.map(o => o.id))
    
    // Emit selection event for tracking
    this.typedEventBus.emit('selection.changed', {
      selection: { type: 'objects', objectIds: objects.map(o => o.id) } as import('@/lib/editor/canvas/types').Selection,
      previousSelection: null
    })
  }
  
  /**
   * Clear object selection
   */
  async clearObjectSelection(): Promise<void> {
    const previousSelection = Array.from(this.canvas.state.selectedObjectIds)
    this.canvas.deselectAll()
    
    if (previousSelection.length > 0) {
      this.typedEventBus.emit('selection.cleared', {
        previousSelection: { type: 'objects', objectIds: previousSelection } as import('@/lib/editor/canvas/types').Selection
      })
    }
  }
} 